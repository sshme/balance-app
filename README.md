# Решение задачи

## Технологии
- **Node.js** (Express, JavaScript)
- **PostgreSQL** (Sequelize ORM)
- **Umzug** (migrate, seed)

## Задачи
1. При запуске приложения создать таблицу `users` в базе данных с помощью миграции и добавить в неё один пользовательский аккаунт с полем `balance`, установленным на 10000.
2. Написать маршрут (route) для обновления баланса пользователя, который принимает параметры `userId` и `amount`, и позволяет изменять баланс как в большую, так и в меньшую сторону.
3. Обеспечить, чтобы баланс пользователя не мог стать отрицательным.
4. Обеспечить обработку 10000 запросов на снятие 2 единиц с баланса пользователя одновременно, при этом 5000 запросов должны успешно выполниться, а остальные 5000 должны получить ошибку о недостаточности средств.

## Решение
Я реализовал два подхода:

### 1. Использование `RETURNING` для `UPDATE` запросов
Postgres поддерживает `RETURNING` для `UPDATE` запросов, что позволяет формировать обновление баланса и получение актуального состояния в один запрос.
- **Маршрут**: `/approach/self/balance`

### 2. Использование транзакций и пессимистичных блокировок
Этот подход использует транзакции и пессимистичные блокировки для обеспечения корректности обновления баланса.
- **Маршрут**: `/approach/transaction-pessimistic-locking/balance`

Также реализован сервис на Go для тестирования обоих решений в папке `go-test`.

## Запуск в dev режиме

### Настройка `.env` файла
Настройте `.env` файл в папке `app` на основе `.env.example`, иначе приложение будет использовать значения по умолчанию.

### Запуск базы данных
```sh
cd app
docker-compose up -d
```

### Запуск приложения
```sh
pnpm install
pnpm run dev
```
Это запустит миграции, сиды и приложение.

### Запуск сервиса для тестирования
```sh
cd go-test
go run main.go
```

## Проверка на корректность работы
Сервис для тестирования отправляет множество параллельных запросов, тестируя оба решения по очереди. В файле `responses.log` можно увидеть результаты тестирования (ответ от сервера со значением баланса, количество повторившихся ответов).

Так как в обоих решениях количество повторившихся ответов совпало с 5000 для сообщения `{"error":"Insufficient funds"}`, что свидетельствует о невозможности выполнения операции снятия с баланса, можно сделать вывод, что оба решения работают корректно.

## Нагрузочное тестирование
В ходе тестирования была использована утилита `wrk` для нагрузочного тестирования сервера с кодом на Lua:

```lua
wrk.method = "PATCH"
wrk.body   = '{"userId": 1, "amount": -2}'
wrk.headers["Content-Type"] = "application/json"
```

Команда для запуска:
```sh
wrk -t12 -c10000 -d10m -s patch_request.lua http://localhost:3000/approach/self/balance
```

## Заключение
Оба подхода успешно справляются с задачей, обеспечивая корректное обновление баланса пользователя и предотвращая его отрицательное значение при одновременной обработке большого количества запросов.