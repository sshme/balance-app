# Решение задачи

## Технологии
- **Node.js** (Express, JavaScript)
- **PostgreSQL** (Sequelize ORM)
- **Umzug** (migrate, seed)

## Задачи
1. При запуске приложения создать таблицу `users` в базе данных с помощью миграции и добавить в неё один пользовательский аккаунт с полем `balance`, установленным на 10000.
2. Написать маршрут (route) для обновления баланса пользователя, который принимает параметры `userId` и `amount`, и позволяет изменять баланс как в большую, так и в меньшую сторону.
3. Обеспечить, чтобы баланс пользователя не мог стать отрицательным.
4. Обеспечить обработку 10000 запросов на снятие 2 единиц с баланса пользователя одновременно, при этом 5000 запросов должны успешно выполниться, а остальные 5000 должны получить ошибку о недостаточности средств.

## Решение
Я реализовал три подхода:

### 1. Использование `RETURNING` для `UPDATE` запросов
Postgres поддерживает `RETURNING` для `UPDATE` запросов, что позволяет формировать обновление баланса и получение актуального состояния в один запрос.
- **Маршрут**: `/api/users/balance/default`
> Этот способ наиболее простой в реализации, но не сработает при более сложных сценариях, таких как обновление нескольких записей одновременно (и хорошо было бы вынести бизнес-логику по аналогии, как это реализовано в других подходах).

### 2. Использование транзакций и пессимистичных блокировок
Этот подход использует транзакции и пессимистичные блокировки для обеспечения корректности обновления баланса.
- **Маршрут**: `/api/users/balance/pessimistic`
> Этот способ более надежен, так как использует блокировки для предотвращения одновременного обновления баланса, но он менее производителен из-за использования пессимистических блокировок (много запросов может висеть одновременно).

### 3. Использование транзакций и оптимистических блокировок
Этот подход использует транзакции и пессимистичные блокировки для обеспечения корректности обновления баланса.
- **Маршрут**: `/api/users/balance/optimistic`
> Этот способ более производителен, так как использует оптимистические блокировки, но не все одновременные запросы будут корректно обработаны. 
> Если необходимо обработать запрос, независимо от ответа на запрос пользователя, можно сделать:
> - Создать таблицу для хранения запросов на обновление баланса
> - Если запрос не прошел по причине параллельного изменения записи, создать запись на повтор запроса.
> - Периодически проверять таблицу на наличие запросов и обрабатывать их (использовать scheduler, фоновый процесс).

Также реализован сервис на Go для тестирования обоих решений в папке `go-test`.

## Запуск в dev режиме

### Настройка `.env` файла
Настройте `.env` файл в папке `app` на основе `.env.example`.

### Запуск с docker-compose
```sh
  cd app
  docker-compose up
```
Это запустит базу, миграции, сиды и приложение.

### Запуск сервиса для тестирования
```sh
  cd go-test
  go run main.go
```

## Нагрузочное тестирование
В ходе тестирования была использована утилита `wrk` для нагрузочного тестирования сервера с кодом на Lua:

```lua
wrk.method = "PATCH"
wrk.body   = '{"userId": 1, "amount": -2}'
wrk.headers["Content-Type"] = "application/json"
```

Команда для запуска:
```sh
wrk -t12 -c10000 -d10m -s patch_request.lua http://localhost:3000/approach/self/balance
```

## Заключение
Оба подхода успешно справляются с задачей, обеспечивая корректное обновление баланса пользователя и предотвращая его отрицательное значение при одновременной обработке большого количества запросов.